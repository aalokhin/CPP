/*Подозреваемый. У него крепкая психика и нет очевидных слабостей, показания из него не выбить.*/
struct Cls {
    Cls(char _c, double _d, int _i);
private:
    char c;
    double d;
    int i;
};
 
/*Брат-близнец подозреваемого. Он знает все о грязных делишках Cls, но сдавать его не спешит, брат все же.*/
struct ClsPubl
{
   /*Суть в том, чтобы подельник был полной копией подозреваемого (только в этом случае поля и методы одного класса будут находится в памяти по тем же смещениям, что и у другого), за исключением наличия семьи и детей.*/
    ClsPubl(char _c, double _d, int _i);
public: /*<--- слабое место в психологии преступника - его близкие.*/
    char c;
    double d;
    int i;
};
 
/*Мы - детективы и уже битый час строим из себя "хорошего полицейского", но все бестолку.*/
/*Пришло время поиграть в "плохих полицейских" с братом подозреваемого...*/
 
char &get_c(Cls &cls) {
    void* voidptr = static_cast<void*>(&cls); /*Преобразуем указатель типа Сls* к типу void*. Как бы между делом замечаем поразительное внешнее сходство с непутевым братом.*/
    struct ClsPubl * p = static_cast<ClsPubl*>(voidptr); /*Преобразуем указатель типа void* к типу ClsPubl*, чтобы получить доступ к полям и методам. Далее говорим, что у нас таки есть свидетель, опознавший вашего брата (блеф, но иначе никак)! Но может это были вы? Что будет если вас посадят вместо него за его преступление? Как потом жить вашей семье? Ведь у них все отнимут в качестве компенсации!*/
    return p->c; /*Парень понимает, что у него нет выхода, и сдает брата-преступника. Преступник наказан, у детективов премия и бурный секс дома. Happy end!*/
    /* Прямое преобразование Сls* к ClsPubl* нелегально и компилятор не пропустит (приравнивается к избиению заключенных), поэтому вначале кастуем к void*. */
}



/*
 * Класс Cls определен точно таким образом:
 *
 * struct Cls {
 * Cls(char c, double d, int i);
 * private:
 *     char c;
 *     double d;
 *     int i;
 * };
 *
 */

// Эта функция должна предоставить доступ к полю c объекта cls.
// Обратите внимание, что возвращается ссылка на char, т. е.
// доступ предоставляется на чтение и запись.
struct Cls2 {
    Cls2(char c, double d, int i);
public:
    char c;
    double d;
    int i;
};


char &get_c(Cls &cls) {
   void* ptr_v = static_cast<void*>(&cls); 
    struct Cls2 *pointr = static_cast<Cls2*>(ptr_v); 
    return pointr->c;

    /* ... */
}

// Эта функция должна предоставить доступ к полю d объекта cls.
// Обратите внимание, что возвращается ссылка на double, т. е.
// доступ предоставляется на чтение и запись.
double &get_d(Cls &cls) {
    void* ptr_v = static_cast<void*>(&cls); 
    struct Cls2 *pointr = static_cast<Cls2*>(ptr_v); 
    return pointr->d;
    /* ... */
}

// Эта функция должна предоставить доступ к полю i объекта cls.
// Обратите внимание, что возвращается ссылка на int, т. е.
// доступ предоставляется на чтение и запись.
int &get_i(Cls &cls) {
     void* ptr_v = static_cast<void*>(&cls); 
    struct Cls2 *pointr = static_cast<Cls2*>(ptr_v); 
    return pointr->i;
    /* ... */
}